- [1. 数据结构与算法](#1-数据结构与算法)
- [2. 数据结构](#2-数据结构)
  - [2.1. 数组、栈、队列](#21-数组栈队列)
  - [2.2. 字符串](#22-字符串)
  - [2.3. 链表](#23-链表)
  - [2.4. 树](#24-树)
  - [2.5. 图](#25-图)
  - [2.6. 堆](#26-堆)
  - [2.7. 哈希表](#27-哈希表)
- [3. 算法](#3-算法)
  - [3.1. 分治算法](#31-分治算法)
  - [3.2. 动态规划](#32-动态规划)
  - [3.3. 搜索与回溯算法](#33-搜索与回溯算法)
  - [3.4. 查找算法](#34-查找算法)
  - [3.5. 贪心算法](#35-贪心算法)
  - [3.6. 排序](#36-排序)
  - [3.7. 位运算](#37-位运算)
  - [3.8. 双指针](#38-双指针)
  - [3.9. 模拟](#39-模拟)
  - [3.10. 数学](#310-数学)

# 1. 数据结构与算法
学习资料：
- [leetcode-图解算法数据结构](https://leetcode.cn/leetbook/detail/illustration-of-algorithm/)
- [leetcode-剑指offer](https://leetcode.cn/study-plan/lcof/?progress=3vlsqe6)

[怎么高效的刷算法题？](https://zhuanlan.zhihu.com/p/344399579)：
- 按照tag来刷
- 多训练。可以看题解，尽量做到能默写下来，形成肌肉记忆
- 解题三部曲
  - 看懂题目
  - 分析，推导解法
  - 思路转化为代码 



# 2. 数据结构
- 线性数据结构：数组、栈、队列、字符串、链表
- 非线性数据结构：树、堆、图、哈希表
## 2.1. 数组、栈、队列
python中这三个都用[list](https://www.runoob.com/python/python-lists.html)来表示。
- cmp、len、max、min、list
- append、count、extend、index、insert、pop、reverse、sort

题目：
- 两个栈来实现队列：一个输入，一个输出，输出不够从输入队列取。负负得正。
- 包含min函数的栈：加一个辅助栈，只存允许当前最小值入栈。
- 滑动窗口最大值：用一个辅助队列from collections import deque，队列保持递减。
- 队列最大值：用一个辅助的双向队列

## 2.2. 字符串
题目：
- 字符串替换空格：数组存储，然后join
- 表示数字的字符串：状态机
- 左旋字符串：字符串切片s[n:]+s[:n],遍历用数组缓存然后join，遍历直接+到str上，切片最快。C++可以用三次翻转，O(1)空间复杂度。
- 字符串转数字。先删除空格str.strip(), 字符转数字ord(c) - ord('0'),

## 2.3. 链表
题目：
- 从尾到头打印链表：双指针做一个逆序
- 复杂链表赋值：一种是用dict缓存。一种就是跟原链表拼接、拆分。


## 2.4. 树
二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。
## 2.5. 图
## 2.6. 堆
## 2.7. 哈希表

# 3. 算法

## 3.1. 分治算法

- 重建二叉树。递归，根据前序遍历和中序遍历的规律确定子树位置。时间O(N)，空间O(N)
- 数值的整数次方。位运算n>>1和n&1, 时间O(logN)
- 打印从 1 到最大的 n 位数。递归dfs+去掉前面的0
- 二叉搜索树的后序遍历序列。辅助单调栈，时间O(N)，空间O(N)
- 数组中的逆序对。计算auc了，用mergesort，时间O(logN)，空间O(N)


## 3.2. 动态规划
分治思想、重叠子问题、最优子结构。一般用来求最大值。

题目：
- 斐波那契数列:a,b=b,a+b
- 青蛙跳台阶问题:就是上一个问题，结果取余a % 1000000007
- 正则表达式：o(MN) 状态转移优点复杂
- 连续子数组最大和：dp[i]=num[i] + max(0,dp[i-1])
- 数字转字符串：跟斐波那切数列很像，要判断两位数是否为10-25之间。a, b = (a + b if "10" <= s[i:i + 2] <= "25" else a), a
- 礼物的最大价值：grid[i][j] += max(grid[i][j - 1], grid[i - 1][j])
- 最长的不含重复字符的子字符串：跟连续子数组最大和有点像，需要另外去判重，判重可以用dict或者线性查找。
- 丑数：o(N) 时间复杂度，n2, n3, n5 = dp[a] * 2, dp[b] * 3, dp[c] * 5
- n 个骰子的点数：和有5n+1种可能
- 股票的最大利润：profit = max(profit, price - cost)

问题看起来复杂，最后代码都很短。会用到数组，dict等数据结构。

## 3.3. 搜索与回溯算法
dfs和bfs。先序遍历(根，左，右)，中序遍历(左，根，右)

题目：
- 矩阵种的路径：dfs，把上级节点置为空避免重复。 O(pow(3,k)MN)
- 机器人的运动范围：bfs，O(MN)
- 树的结构：O(MN)时间，O(M)空间，递归调用dfs
- 二叉树的镜像：一种是递归dfs，一种是辅助队列bfs
- 对称二叉树：递归调用，recur(L.left, R.right) and recur(L.right, R.left)
- 从上到下打印二叉树。bfs
- 二叉树中和为某一值的路径。加一个path的缓存
-  二叉搜索树与双向链表。dfs中序遍历
-  序列化二叉树。看到这里优点无聊了，就是bfs层序遍历，叶子节点用null表示
-  字符串的排列。dfs，时间O(N!N),空间O(N*N)
-  二叉搜索树的第 k 大节点。二叉搜索树的中序遍历为升序。 时间O(N)，空间O(N)
-  二叉树的深度。时间O(N)，空间O(N)。后序遍历或者bfs
-  平衡二叉树。时间O(N)，空间O(N)，max(left, right) + 1 if abs(left - right) <= 1 else -1，后序遍历 + 剪枝 （从底至顶）
-  求1+2+...+n：递归+用and旁路替代if， n > 1 and self.sumNums(n - 1)
-  二叉搜索树的最近公共祖先。迭代，时间O(N)，空间O(1)。
-  二叉树的最近公共祖先。先序遍历，时间O(N)，空间O(N)

## 3.4. 查找算法

- 数组中重复的数字：字典；原地交换；O(N)
- 二维数组中的查找：左下角开始二分查找  O(M+N)
- 旋转数组的最小数字：O(logN) 二分查找比较末尾数字
- 第一个只出现一次的字符：dict或者collections.OrderedDict()
- 在排序数组中查找数字 I：二分查找。右边界-左边界
- 0～n-1 中缺失的数字，二分，index和value比较

## 3.5. 贪心算法
## 3.6. 排序
![排序算法](./../../static/img/sortalg.png/sortalg.png)
- 冒泡排序，时间O(NN)，空间O(1)
  - 加一个flag标志位，提前退出，最优时间O(N)
- 插入排序
- 选择排序
- 快速排序,不稳定，时间O(NlogN)，最差O(NN)，空间O(N)
  -  Tail Call： 仅对 较短的子数组 执行哨兵划分
  -  随机基准数
- 归并排序，稳定排序，时间O(NlogN)，空间O(N)
- 堆排序
- 基数排序
- 桶排序

题目：
- 最小的k个数：快排，只用排前k个
- 数据流中的中位数：小顶堆+大顶堆。
- 把数组排成最小的数：转换成str再快排
- 扑克牌中的顺子：dict+max-min,

## 3.7. 位运算

- 二进制中 1 的个数：n &= n - 1 和 n&1
- 数组中数字出现的次数: 异或^，有两个数字，所以要先区分以下，用不同的那个位来区分
- 数组中数字出现的次数 II：数各二级制位出现的次数，只出现一次的就是那个数字。用位运算来模拟3进制。
- 不用加减乘除做加法：a, b = (a ^ b), (a & b) << 1 & x

## 3.8. 双指针

- 删除链表的节点：pre，cur
- 调整数组顺序使奇数位于偶数前面：跟partition一样，用i和j
- 链表中倒数第 k 个节点：第一步先统计长度n，然后遍历n-k步
- 合并两个排序的链表：merge
- 两个链表的第一个公共节点：链表串起来 AB和BA比较
- 和为 s 的两个数字：头尾指针
- 翻转单词顺序：两个指针确定word的头尾

## 3.9. 模拟
## 3.10. 数学

- 剪绳子：尽量按照3来分
- 剪绳子 II：用二分法求幂指数
- 数组中出现次数超过一半的数字：相同加1，不同减一
- 1～n 整数中 1 出现的次数：每个位的1的个数 high * digit + low + 1
- 数字序列中某一位的数字：count=9*digit*start
- 和为 s 的连续正数序列: 双指针
- 圆圈中最后剩下的数字：约瑟夫环，x = (x + m) % i
- 构建乘积数组：两个三角